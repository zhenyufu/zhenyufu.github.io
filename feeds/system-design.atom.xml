<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>csmojo - System Design</title><link href="https://csmojo.com/" rel="alternate"></link><link href="https://csmojo.com/feeds/system-design.atom.xml" rel="self"></link><id>https://csmojo.com/</id><updated>2021-02-20T16:38:13-08:00</updated><entry><title>Book Notes : Designing Data-Intensive Applications</title><link href="https://csmojo.com/posts/book-notes-designing-data-intensive-applications.html" rel="alternate"></link><published>2021-02-20T16:38:13-08:00</published><updated>2021-02-20T16:38:13-08:00</updated><author><name>David</name></author><id>tag:csmojo.com,2021-02-20:/posts/book-notes-designing-data-intensive-applications.html</id><summary type="html">Good Book on System Design. To be updated.</summary><content type="html">&lt;p&gt;Good Book on System Design. To be updated.&lt;/p&gt;
&lt;h4&gt;Notes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Part 1. Basics &lt;ul&gt;
&lt;li&gt;1 Core ideas &lt;ul&gt;
&lt;li&gt;three main concerns of software systems  &lt;ul&gt;
&lt;li&gt;Reliability: The system should continue to work correctly &lt;ul&gt;
&lt;li&gt;Good fault tolerance as it is impossible to reduce fault to zero&lt;/li&gt;
&lt;li&gt;Deliberately inducing faults to test the system&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scalability: The system's ability to cope with increased load&lt;ul&gt;
&lt;li&gt;The system can grow and scale with easy&lt;/li&gt;
&lt;li&gt;eg. Designing Twitter: use a hybrid approach for common users and celebrities&lt;/li&gt;
&lt;li&gt;Scaling&lt;ul&gt;
&lt;li&gt;vertical scaling: making the machine more powerful&lt;/li&gt;
&lt;li&gt;horizontal scaling: distributing the load across multiple machines &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Maintainability: Different people can work on the system productively &lt;ul&gt;
&lt;li&gt;Design principles &lt;ul&gt;
&lt;li&gt;Operability: make it easy for the ops team to keep it running&lt;/li&gt;
&lt;li&gt;Simplicity: keeping it as simple and avoid complexity. make it easy for new engineers to onboard &lt;/li&gt;
&lt;li&gt;Evolvability: make it easy for changes into the future&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2 DB: Data models and query &lt;ul&gt;
&lt;li&gt;relational document and graph&lt;/li&gt;
&lt;li&gt;Object-Relational Mismatch (impedance mistmatch): db is relational while app code is object oriented &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3 DB: Data storage &lt;ul&gt;
&lt;li&gt;storage engines: log structured, page oriented &lt;/li&gt;
&lt;li&gt;increasing db index speeds up reads, but slows down writes &lt;/li&gt;
&lt;li&gt;SSTable (sorted string table): key value storage -&amp;gt; LSM-tree &lt;/li&gt;
&lt;li&gt;B-tree: self-balancing tree that maintains sorted data &lt;/li&gt;
&lt;li&gt;Column Oriented Storage &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4 Encoding &lt;ul&gt;
&lt;li&gt;changes happen to requirements, application code, and data -&amp;gt; compatibility&lt;ul&gt;
&lt;li&gt;backward compatibility: newer code can read data that was written by older code &lt;/li&gt;
&lt;li&gt;forward compatibility : older code can read data that was written by newer code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Formats (need encoding and decoding between the two) &lt;ul&gt;
&lt;li&gt;in memory: objects and data structures (decoding: parsing, deserialization, unmarshalling)&lt;/li&gt;
&lt;li&gt;on disk/over network: encoded (encoding: serialization, marshalling) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;encodings&lt;ul&gt;
&lt;li&gt;JSON, XML, CSV&lt;ul&gt;
&lt;li&gt;problems&lt;ul&gt;
&lt;li&gt;ambiguity around encoding of numbers. precision ? &lt;/li&gt;
&lt;li&gt;No binary string support &lt;/li&gt;
&lt;li&gt;Optional schema support for XML and JSON, none for CSV&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;binary encoding: more compact &lt;ul&gt;
&lt;li&gt;binary encoding libraries: Protocol Buffers, Apache Thrift&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;schema evolution&lt;ul&gt;
&lt;li&gt;adding a field: &lt;ul&gt;
&lt;li&gt;backward: can't make it required, must be optional or have a default value&lt;/li&gt;
&lt;li&gt;forward: adding new field is fine, as long as it is a new tag number&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;removing a field: &lt;ul&gt;
&lt;li&gt;backward: can only remove a field that is optional  &lt;/li&gt;
&lt;li&gt;forward: can never use the same tag number again&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;renaming a field: is like removing and adding at the same time: do this with caution&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Part 2. Distributed &lt;ul&gt;
&lt;li&gt;5 replication &lt;/li&gt;
&lt;li&gt;6 Partitioning/Sharding &lt;/li&gt;
&lt;li&gt;7 Transactions &lt;/li&gt;
&lt;li&gt;8 Failovers &lt;/li&gt;
&lt;li&gt;9 Consistency&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Part 3. Processing Data &lt;ul&gt;
&lt;li&gt;10 Batch&lt;/li&gt;
&lt;li&gt;11 Stream&lt;/li&gt;
&lt;li&gt;12 Future &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="System Design"></category></entry></feed>